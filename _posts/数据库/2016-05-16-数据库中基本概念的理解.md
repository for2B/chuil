---
layout:     post
title:      "数据库中基本概念的理解"
subtitle:   ""
date:       2019-05-16
author:     "CHuiL"
header-img: "img/database-bg.png"
tags:
    - 数据库
---

## 数据库的完整性
指数据的正确性和相容性；
- 正确性指数据是符合现实世界语义的
- 相容性指数据库同一对象在不同关系表中的数据是符合逻辑的。
数据库完整性是为了防止数据库中存在不符合语义的数据。

#### 实体完整性（定义主键）
利用约束 PRIMARY KEY来定义。

#### 参照完整性（外键）
利用FOREIGN KEY来定义

#### 用户定义的完整性
各种约束条件。

#### 使用触发器
触发器是用户定义在关系表上的一类由时间驱动的特殊过程。

### 维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？
我是这样做的，尽==可能使用约束==，如==check,主键，外键，非空字段==等来约束，这样做效率最高，也最方便。其次是使用==触发器==，这种方法可以保证，==无论什么业务系统访问数据库都可以保证数据的完整新和一致性==。最后考虑的是自写业务逻辑，但这样做麻烦，编程复杂，效率低下。

## 存储过程
存储过程是一些==预编译的SQL语句==。

更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。

- 存储过程是一个预编译的代码块，执行效率比较高
- 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率
- 可以一定程度上确保数据安全

### 什么是存储过程？用什么来调用？
存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。

## 触发器
触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。

## 视图
视图是一种==虚拟的表==，具有和物理表相同的功能。==可以对视图进行增，改，查，操作==，视图通常是==由一个表或者多个表的行或列的子集==。对==视图的修改不影响基本表==。它使得我们获取数据更容易，相比多表查询。
- ==只暴露部分字段给访问者==，所以就建一个虚表，就是视图。
- ==查询的数据来源于不同的表，而查询者希望以统一的方式查询==，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异

## 分表分库

### 垂直分表
当表中字段比较多时，可以把数据列拆分到不同的表中，一般按以下原则拆分
- 把不常用的列放在一个表
- 把常用的列放在一个表
- 把text等大字段放在一个表  
#### 优劣
拆分更便于开发和维护，不过需要在数据库设计阶段就做好。

### 垂直分库分表
就是不同表放在不同数据库上。

### 水平分表
为了降低单表数据量，可以将表中不同数据行按照一定规律分布到不同的数据库表中（这些表在同一个数据库中）。最常用的方式是通过主键或时间等字段进行Hash或取模后拆分。
#### 优劣
能够降低单表的数据量，一定程度上可以缓解查询性能。但是所有表都还在一个数据库中，所以库级别还是会有IO瓶颈。一般不采用这种做法

### 水平分库分表
思想与水平分表相同，只是这些表保存在不同的数据库中。一般都采用这种做法。




## 乐观锁，悲观锁

### 悲观锁
- 指的是对数据被外界（其他事务）修改持悲观态度。所以，在对数据处理的整个过程中都处于锁定的状态。其他修改必须先获得锁才能修改。
- 悲观锁的实现需要依靠数据库的锁机制。
- 优点：保证了数据安全
- 缺点：效率较低，且有死锁的风险。在只读的情况下加锁没有必要，增加系统开销。


### 乐观锁
- 对外界修改数据持乐观态度。认为并发事务并不会彼此影响，各事务能够在不使用锁的情况下处理各自影响的那部分数据。
- 所以一般只在提交数据的时候进行检查，如果检查出期间被修改过，则会执行回滚。
- 一般依靠对数据添加版本号来进行检查，提交时读取版本号，检查与旧版本是否一致，一致的话更新，不一致回滚。
- 优点：乐观锁情况下认为数据竞争的概率较小，所以会一直进行下去直到提交前才会去锁定，所以不会产生死锁。
- 缺点：因为在提交前会一直进行下去，所以高并发情况下就会出现问题。



## 参考
http://www.cnblogs.com/knowledgesea/archive/2013/01/02/2841588.html

