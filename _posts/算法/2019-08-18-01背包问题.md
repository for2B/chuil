---
layout:     post
title:      "01背包问题"
subtitle:   ""
date:       2019-08-18
author:     "CHuiL"
header-img: "img/algorithm-bg.png"
tags:
    - 算法
---

### 问题
当前有n件物品，每件物品都价值v，和重量w两个属性；我们手上还有一个背包，设背包最大所能容纳的重量为C。求如何拿取物品才能使在有限容量的背包中所获得的价值最大。

### 解体思路
使用动态规划来解决这一问题，当我们来到第i件物品时，我们的包里还有容量c，我们希望选择的结果能使价值最大，所以我们可以设B(i,c)表示在面临第i件物品时，包里容量还有c的情况下的所能拿取的最大值。  
例如我们有1，2，3，4，5 一共五件物品，总容量为C；那么B(5,20)表示面临第5件物品时，且容量为20的最大值价值，也即最终的最大价值。
而在面临第5件物品时，有三种选择情况
1. 容量足够，拿取第5件物品；则B(5,20) =  B(4,20-w5)+v5;即拿取第五件物品之后，接下来面对的就是后面的物品。B(4,20-w5)就是用剩余的容量拿取后面的物品所能得到的最大价值。
2. 容量足够，不拿取第五件物品;则B(5,20) = B(4,20);同理，用容量20去拿取后面的物品所获得的最大值。
3. 容量不足，不拿取;B(4,20);

所以我们可以总结出以下公式  

![image](/chuil/img/algorithm/19-08-22-2.png)



#### 构建dp二维表来存储
每一行代表所能选择到的所有物品，每一列代表当前总容量（0~C）。  

![image](/chuil/img/algorithm/19-08-22-3.png)

```
type Element struct {
	W int
	v int
}

func Knapsack10(elemt []Element, C int)int{
	N := len(elemt)

	DP := make([][]int,N+1,N+1)
	for i,_ := range DP{
		DP[i] = make([]int,C+1)
	}

	for i:=1;i<=N;i++{
		for c:=0;c<=C;c++{
			if elemt[i-1].W>c{
				DP[i][c] = DP[i-1][c]
			}else{
				DP[i][c] = Max(DP[i-1][c],DP[i-1][c-elemt[i-1].W]+elemt[i-1].v)
			}
		}
	}

	fmt.Println(DP[N][C])
	return DP[N][C]
}
```

#### 将二维的数组转换为一维数组
将原来的容量的遍历顺序逆序，这样便可以保证dp[c]代表的是dp[i-1][c]了。
而且遍历容量的时候，重量为v的物品不会影响0~v之间的状态。

```
type Element struct {
	W int
	v int
}


func Knapsack10(elemt []Element, C int)int{
	N := len(elemt)

	DP := make([]int,C+1)

	for i:=1;i<=N;i++{
		for c:=C;c>=elemt[i-1].W;c--{
			if elemt[i-1].W>c{
				DP[c] = DP[c]
			}else{
				DP[c] = Max(DP[c],DP[c-elemt[i-1].W]+elemt[i-1].v)
			}
		}
	}

	fmt.Println(DP[C])
	return DP[C]
}
```


## leetcode上的类似题目
#### 416. Partition Equal Subset Sum
大意就是给定一个整型数组，求该数组能否分为两个子数组，要求他们的和相等；  
[这道题之前就已经做过了](https://for2b.github.io/chuil/2019/06/27/416.-Partition-Equal-Subset-Sum/)，但是并没有做出来，也是看到别人的解法，看了好久勉强了别人的做法。  
现在重新学了01背包问题，再去看这道题发现就是01背包的问题。。

这里转换一下，把每个值看成重量，问题就变成，能否从这堆物品中找出重量刚好为总重量的一半的物品； 
对于每一个物品，都有那或者不拿的选择，设有dp[i][w]表示共有i件物品，是否能凑齐重量刚好为w；那么dp[i][w] = dp[i-1][w]||dp[i-1][w-nums[i]]  
不拿就看后面的能否凑够w，拿了就看后面的能否凑够w-nums[i]；是不是就是01背包问题，构造相同的二维表，只是不在是表示价值，而单纯只是一个true false而已；
这样去想这道题就容易很多，之前借鉴的解法看了半天才理解，理解之后就马上忘记了。
```
func canPartition(nums []int) bool {
    sum:=0
    for _,n:=range nums{
        sum+=n
    }
    if sum&1==1{
        return false
    }
    
    target := sum>>1
    
    dp := make([]bool,target+1)
    dp[0]=true
    for _,num:=range nums{
        for i:=target;i>=num;i--{
            dp[i] = dp[i]||dp[i-num]
        }
    }
    
    return dp[target]
    
```

#### 474. Ones and Zeroes  
In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.

For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.

Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.    

大意就是，m，n分别代表0 和 1的个数，在给你个字符串数组，每个字符由01构成，问从这个数组中找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。

例子
```
Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
Output: 4

Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”
```
  

这道题也是01背包问题，只是价值重量转化为0 1 的个数而已,同样可以得到类似的状态转化方程
`dp[i][m][n] = max(dp[i-1][m][n],dp[i-1][m-Mi][n-Ni]+1`   
在熟悉了上面的解法，这个方程也不难理解了，就是在对第i个字符时，有选择拿去它或者不拿取它，不拿去则最大数量由后面字符的决定，拿去了则将M，N的个数对应的减少，总量+1；同样是构造二维表  
这里的二维表中，可以看成i,(m,n)的形式；

代码如下

```
func findMaxForm(strs []string, m int, n int) int {
	dp := make([][]int,m+1)
	for i,_:=range dp{
		dp[i] = make([]int,n+1)
	}

	for _,s := range strs{
		count0 := strings.Count(s, "0")
		count1 := len(s) - count0

		if count0>m || count1 > n{
			continue
		}

		for M:=m;M>=count0;M--{
			for N:=n;N>=count1;N--{
				dp[M][N] = max(dp[M][N],dp[M-count0][N-count1]+1)
			}
		}
	}
	return dp[m][n]
}
```
