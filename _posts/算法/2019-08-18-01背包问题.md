---
layout:     post
title:      "01背包问题"
subtitle:   ""
date:       2019-08-18
author:     "CHuiL"
header-img: "img/algorithm-bg.png"
tags:
    - 算法
---

### 问题
当前有n件物品，每件物品都价值v，和重量w两个属性；我们手上还有一个背包，设背包最大所能容纳的重量为C。求如何拿取物品才能使在有限容量的背包中所获得的价值最大。

### 解体思路
使用动态规划来解决这一问题，当我们来到第i件物品时，我们的包里还有容量c，我们希望选择的结果能使价值最大，所以我们可以设B(i,c)表示在面临第i件物品时，包里容量还有c的情况下的所能拿取的最大值。  
例如我们有1，2，3，4，5 一共五件物品，总容量为C；那么B(5,20)表示面临第5件物品时，且容量为20的最大值价值，也即最终的最大价值。
而在面临第5件物品时，有三种选择情况
1. 容量足够，拿取第5件物品；则B(5,20) =  B(4,20-w5)+v5;即拿取第五件物品之后，接下来面对的就是后面的物品。B(4,20-w5)就是用剩余的容量拿取后面的物品所能得到的最大价值。
2. 容量足够，不拿取第五件物品;则B(5,20) = B(4,20);同理，用容量20去拿取后面的物品所获得的最大值。
3. 容量不足，不拿取;B(4,20);

所以我们可以总结出以下公式  

![image](/chuil/img/algorithm/19-08-22-2.png)



#### 构建dp二维表来存储
每一行代表所能选择到的所有物品，每一列代表当前总容量（0~C）。  

![image](/chuil/img/algorithm/19-08-22-3.png)

```
type Element struct {
	W int
	v int
}

func Knapsack10(elemt []Element, C int)int{
	N := len(elemt)

	DP := make([][]int,N+1,N+1)
	for i,_ := range DP{
		DP[i] = make([]int,C+1)
	}

	for i:=1;i<=N;i++{
		for c:=0;c<=C;c++{
			if elemt[i-1].W>c{
				DP[i][c] = DP[i-1][c]
			}else{
				DP[i][c] = Max(DP[i-1][c],DP[i-1][c-elemt[i-1].W]+elemt[i-1].v)
			}
		}
	}

	fmt.Println(DP[N][C])
	return DP[N][C]
}
```

#### 将二维的数组转换为一维数组
将原来的容量的遍历顺序逆序，这样便可以保证dp[c]代表的是dp[i-1][c]了。
而且遍历容量的时候，重量为v的物品不会影响0~v之间的状态。

```
type Element struct {
	W int
	v int
}


func Knapsack10(elemt []Element, C int)int{
	N := len(elemt)

	DP := make([]int,C+1)

	for i:=1;i<=N;i++{
		for c:=C;c>=elemt[i-1].W;c--{
			if elemt[i-1].W>c{
				DP[c] = DP[c]
			}else{
				DP[c] = Max(DP[c],DP[c-elemt[i-1].W]+elemt[i-1].v)
			}
		}
	}

	fmt.Println(DP[C])
	return DP[C]
}
```